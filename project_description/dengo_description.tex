\section{\dengo{}: Solver Generation}

A computational solver for chemical kinetic rate equations is the synthesis of
three primary components: 1) a set of reactions and their affiliated species,
2) a collection of reaction rate coefficients and 3) the mechanism of updating
the state vector from one time to a future time.  Ensuring that a collection of
reaction rate coefficients is up to date with current theoretical or
experimental values is straightforward; this requires tracking changes in the
literature and modifying the input parameters to interpolation tables.

However, when a reaction network requires scaling to a large number of species
or a large number of reactions (particularly when the connectivity of the
network is high) the complexity of modifying this reaction network increases
rapidly.  Adding a single reaction requires modifying the right-hand side
calculation for all species that appear in that reaction.  This poses
challenges to ensuring bookkeeping between reaction rates and species are
correct -- which is a tedious but tractable issue -- but poses entirely new
challenges when the solver itself is built into the reaction network.  This may
be the case, for instance, when conducting a Gauss-Seidel update of the
reaction state vector \textit{during} the timestep update, as is done in
grackle.

Further complicating the matter is that, while strictly separable from the
other two components, often the solver itself is written to be intertwined with
these.  The two primary modes used in astrophysical calculations are explicit
solvers (where we consider semi-implicit to be a subset) and fully-implicit
solvers; the latter are typically regarded as considerably slower than the
former.  The construction of a solver, and the inherent bookkeeping, is prone
to error, time-consuming, and is inflexible for simple transformations between
solver methodologies; writing an explicit or semi-implicit solver is an
entirely different process than writing a fully-implicit solver, and the
mixture of the model with the implementation is non-trivial.  Furthermore, when
interconnecting multiple species in non-linear, often non-trivial ways,
calculation of a Jacobian requires complex and extensive differentiation.

Advances in open source computer algebra systems (CAS) such as SymPy \mjt{CITE
SYMPY} enable the symbolic and computational description of reaction rate
networks that can be symbolically and numerically differentiated, as well as
output into a templated format.  For instance, constructing a reaction network
composed of a few dozen chemical species and a few hundred reactions can be
accomplished in only as many lines of code as is necessary to describe them.
These reaction networks can have Jacobians (exact or approximate) computed 
and they preserve the notion of an abstract model that can be instantiated into
one or more different concrete representations of a chemical solver.

At present, Grackle is a hand-written code, where the order of update, solver
prescriptions, interpolation of rates and the timestep estimate are all
intertwined with each other.  This reduces its overall flexibility, but it does
provide an opportunity for fine-grained and situation-aware optimization such
as update ordering.  However, it does not provide the flexibility, automated
bookkeeping and solver interoperability as would be provided through alternate,
symbolically defined reaction systems.

To address these limitations, we will further develop the project ``Dengo"
started by Co-I Turk; this is a solver construction kit based on a combination
of SymPy and the templating library Jinja2.  Utilizing the existing Grackle
solver as a reference implementation, we will unify the two projects; Dengo
accepts reaction networks, chemical species (and their metadata), reaction
rates, and an API or implementation of an iterative solver, and generates
templated output code.  At present, Dengo can generate C code with Python
interfaces, utilizing either a backwards-Euler iterative solver or the SUNDIALS
suite of tools; furthermore, it has been recently instrumented to generate
OpenMP-aware code, although testing is still underway to ensure correctness and
scalability.

\mjt{cite sundials}



The rate transformation of one species to another due to two-body chemical kinetic
reactions can be written down in this form:

$$
\frac{\partial n_i }{\partial t} = \sum_{j}\sum_{l} k_{jl}n_{j}n_{l} + \sum_{j}I_{j}n_{j}
$$

Here, we use $n_{i}$ to denote species $i$, ${k_jl}$ to denote the kinetic rate
coefficient for the reaction between species $j$ and $l$ that produces species
$i$, and $I_{j}$ is the radiative process rate from $j$ to $i$.  Primordial
chemistry also often includes three-body reactions, such as those that
form molecular hydrogen while utilizing a third body as a catalyst.  It is
notable that this defines the \textit{entire} system of two-body reactions;
where we see reductions in species, the reaction rate is negative and includes
species ${i}$.

\mjt{Gotta think about perceived weaknesses}

Generating a reaction network from this involves constructing a change vector,
$\frac{\partial n_i}{\partial t}$ for all pairwise combinations and sets of
reactions.  From the perspective of implementation, this requires considerable
bookkeeping for each additional species and each additional reaction.  For
example, adding a single reaction rate that operates on two species requires
updating the species change vectors for each of those two species; when
optimizing for computational architectures -- such as SIMD instructions, memory
management for interpolation tables, and reducing cache misses -- this adds
not-inconsiderable overhead for the developer.  Furthermore, operations that
change the mechanism by which the solver operates, such as changing from
semi-implicit updates to a fully-implicit scheme, require full reorganization
of the solver code.

Dengo is a platform for generating chemical kinetic rate equation solvers that
remain independent of the mechanism for executing that solution.

\mjt{Add diagram of how Dengo works -- maybe some boxes}

Dengo includes full reaction networks for primordial gas, ionization of
interstellar, and formation of molecules using \mjt{UMIST}.  Constructing a
solver using Dengo is done by choosing a collection of species to evolve,
choosing the relevant chemical kinetic and radiative cooling equations that
interlink them, and then identifying the solver that will update the coupled
differential equations at each timestep.


\mjt{Cite: sympy}

Figures of merit?

Implementation?
